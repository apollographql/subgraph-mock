# The port to listen on (currently the graphql endpoint is simply served on "/"
# but support for serving different subgraphs at different routes is planned
port: 8080

# Whether or not cache responses against the hash of the request 'query' field
# in order to reduce natural (non-injected) latency and resource usage.
# This is not always desirable but is sometimes needed when working with graphs
# that use giant queries like Expedia.
cache_responses: true

# Additional response headers to set for every response.
# "Content-type: application/json" is automatically set for all graphQL responses
# by default.
headers:
  MyHeader: "my-header-value"

# Currently matching the latency generation config from the router-scale Go
# "subgraph" mock server.
# Total latency is the sum of the base latency and any defined waveforms.
latency:
  # Base latency to apply _after_ response generation.
  base: 5ms
  # Latency waveforms: allowed keys are "sine", "saw", "square", "triangle"
  # and all options have the same sub-keys of "amplitude" and "period" for
  # the waveform.
  sine:
    amplitude: 2ms
    period: 10s

# Configuration for how responses should be generated for incoming graphQL
# requests. What is shown below is the current default configuration that
# will be used. Additional scalar generators can be defined and the existing
# defaults can be overwritten as needed.
response_generation:
  # How frequently to set nullable fields to null
  null_ratio: [1, 2]
  # How frequently to include a particular header
  header_ratio:
    MyHeader: [1, 3]
  # Minimum and maximum lengths for array fields
  array:
    min_length: 0
    max_length: 10
  # Custom scalar generators. Below is the default setup for built-in
  # scalars plus "ID". Keys must exactly match the scalar name found
  # in the schema provided to the server, unmatched scalars will be
  # defaulted to being represented as strings with lengths 1-10.
  scalars:
    Bool:
      type: bool
    Float:
      type: float
      min: -1.0
      max: 1.0
    Int:
      type: int
      min: 0
      max: 100
    Id:
      type: int
      min: 0
      max: 100
    String:
      type: string
      min_len: 1
      max_len: 10

# Any value except the listening port in the configuration can be
# overridden at a per-subgraph level. Subgraphs do not map 1:1 with
# running servers so the port must remain a shared configuration.
subgraph_overrides:
  # Each subgraph is a top-level key in the overrides and must match
  # the name that the router will try to hit when making a request.
  my_subgraph_name:
    # Any overrides here will be merged with the values provided in
    # the base configuration.
    cache_responses: false
    response_generation:
      null_ratio: [1, 5]
      header_ratio:
        MyHeader: [1, 4]
      array:
        min_length: 5
